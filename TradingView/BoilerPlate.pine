//@version=5
indicator("0x7C2f's Boilerplate", shorttitle="Boilerplate", format=format.price, precision=0, overlay=true, max_lines_count = 500, max_labels_count = 500, max_boxes_count = 500)

// Daily & Weekly Bars
override_offset = input.bool(false, title="Override defaul offset", inline = "utc_offset")
utc_offset_input = input.int(-6, title="Offset of UTC time", minval=-12, maxval=12, inline = "utc_offset")
week_color = input.color(color.black, "Weekly separator color")
day_color = input.color(#5d606b, "Daily separator color")
if not override_offset
    if syminfo.type == "index" or syminfo.type == "futures"
        utc_offset_input := -7
    if syminfo.type == "forex" or syminfo.ticker == "DXY"
        utc_offset_input := -6
offset_in_ms = utc_offset_input * 60 * 60 * 1000
week_of_year_changed = weekofyear(time-offset_in_ms) != weekofyear(time-1-offset_in_ms)
day_of_week_changed = dayofweek(time-offset_in_ms) != dayofweek(time-1-offset_in_ms)
if week_of_year_changed
    line.new(bar_index, 100, bar_index, -100, color=week_color, width=4, style=line.style_solid)
if day_of_week_changed and not week_of_year_changed
    line.new(bar_index, 100, bar_index, -100, color=day_color, width=2, style=line.style_dotted)

// Ichimoku Cloud
conversionPeriods = input.int(9, minval=1, title="Conversion Line Length")
basePeriods = input.int(26, minval=1, title="Base Line Length")
laggingSpan2Periods = input.int(52, minval=1, title="Leading Span B Length")
displacement = input.int(26, minval=1, title="Lagging Span")

donchian(len) => math.avg(ta.lowest(len), ta.highest(len))

conversionLine = donchian(conversionPeriods)

baseLine = donchian(basePeriods)

leadLine1 = math.avg(conversionLine, baseLine)
leadLine2 = donchian(laggingSpan2Periods)

p1 = plot(leadLine1, offset = displacement - 1, color=#A5D6A7,
	 title="Leading Span A")
p2 = plot(leadLine2, offset = displacement - 1, color=#EF9A9A,
	 title="Leading Span B")
plot(leadLine1 > leadLine2 ? leadLine1 : leadLine2, offset = displacement - 1, title = "Kumo Cloud Upper Line", display = display.none) 
plot(leadLine1 < leadLine2 ? leadLine1 : leadLine2, offset = displacement - 1, title = "Kumo Cloud Lower Line", display = display.none) 
fill(p1, p2, color = leadLine1 > leadLine2 ? color.rgb(67, 160, 71, 90) : color.rgb(244, 67, 54, 90))


// RSI
rsi_length = input.int(14, title="RSI Length")
rsi_src = input(close, title="RSI Source")
rsi_val = ta.rsi(rsi_src, rsi_length)
plot(rsi_val, title="RSI", color=color.rgb(126, 87, 194) )

// Liquidity Swings

//------------------------------------------------------------------------------
//Settings
//-----------------------------------------------------------------------------{
length = input(14, 'Pivot Lookback')

area = input.string('Wick Extremity', 'Swing Area', options = ['Wick Extremity', 'Full Range'])

intraPrecision = input(false, 'Intrabar Precision', inline = 'intrabar')
intrabarTf = input.timeframe('1', '', inline = 'intrabar')

filterOptions = input.string('Count', 'Filter Areas By', options = ['Count', 'Volume'], inline = 'filter')
filterValue   = input.float(0, ''                                            , inline = 'filter')

//Style
showTop      = input(true, 'Swing High', inline = 'top', group = 'Style')
topCss       = input(color.red, '', inline = 'top', group = 'Style')
topAreaCss   = input(color.new(color.red, 50), 'Area', inline = 'top', group = 'Style')
showBtm      = input(true, 'Swing Low', inline = 'btm', group = 'Style')
btmCss       = input(color.teal, '', inline = 'btm', group = 'Style')
btmAreaCss   = input(color.new(color.teal, 50), 'Area', inline = 'btm', group = 'Style')
labelSize = input.string('Tiny', 'Labels Size', options = ['Tiny', 'Small', 'Normal'], group = 'Style')

//-----------------------------------------------------------------------------}
//Functions
//-----------------------------------------------------------------------------{
n = bar_index

get_data()=> [high, low, volume]

[h, l, v] = request.security_lower_tf(syminfo.tickerid, intrabarTf, get_data())
get_counts(condition, top, btm)=>
    var count = 0
    var vol = 0.

    if condition
        count := 0
        vol := 0.
    else
        if intraPrecision
            if n > length
                if array.size(v[length]) > 0
                    for [index, element] in v[length]
                        vol += array.get(l[length], index) < top and array.get(h[length], index) > btm ? element : 0
        else
            vol += low[length] < top and high[length] > btm ? volume[length] : 0
        
        count += low[length] < top and high[length] > btm ? 1 : 0

    [count, vol]

set_label(count, vol, x, y, css, lbl_style)=>
    var label lbl = na
    var label_size = switch labelSize
        'Tiny' => size.tiny
        'Small' => size.small
        'Normal' => size.normal

    target = switch filterOptions
        'Count'  => count
        'Volume' => vol

    if ta.crossover(target, filterValue)
        lbl := label.new(x, y, str.tostring(vol, format.volume)
          , style = lbl_style
          , size = label_size
          , color = #00000000
          , textcolor = css)

    if target > filterValue
        label.set_text(lbl, str.tostring(vol, format.volume))

set_level(condition, crossed, value, count, vol, css)=>
    var line lvl = na

    target = switch filterOptions
        'Count'  => count
        'Volume' => vol

    if condition
        if target[1] < filterValue[1]
            line.delete(lvl[1])
        else if not crossed[1]
            line.set_x2(lvl, n - length)

        lvl := line.new(n - length, value, n, value
          , color = na)

    if not crossed[1]
        line.set_x2(lvl, n+3)
    
    if crossed and not crossed[1]
        line.set_x2(lvl, n)
        line.set_style(lvl, line.style_dashed)

    if target > filterValue
        line.set_color(lvl, css)

set_zone(condition, x, top, btm, count, vol, css)=>
    var box bx = na

    target = switch filterOptions
        'Count'  => count
        'Volume' => vol

    if ta.crossover(target, filterValue)
        bx := box.new(x, top, x + count, btm
          , border_color = na
          , bgcolor = css)
    
    if target > filterValue
        box.set_right(bx, x + count)

//-----------------------------------------------------------------------------}
//Global variables
//-----------------------------------------------------------------------------{
//Pivot high
var float ph_top = na
var float ph_btm = na
var bool  ph_crossed = na
var       ph_x1 = 0
var box   ph_bx = box.new(na,na,na,na
  , bgcolor = color.new(topAreaCss, 80)
  , border_color = na)

//Pivot low
var float pl_top = na
var float pl_btm = na
var bool  pl_crossed = na
var       pl_x1 = 0
var box   pl_bx = box.new(na,na,na,na
  , bgcolor = color.new(btmAreaCss, 80)
  , border_color = na)

//-----------------------------------------------------------------------------}
//Display pivot high levels/blocks
//-----------------------------------------------------------------------------{
ph = ta.pivothigh(length, length)

//Get ph counts
[ph_count, ph_vol] = get_counts(ph, ph_top, ph_btm)

//Set ph area and level
if ph and showTop
    ph_top := high[length]
    ph_btm := switch area 
        'Wick Extremity' => math.max(close[length], open[length])
        'Full Range' => low[length]
    
    ph_x1 := n - length
    ph_crossed := false

    box.set_lefttop(ph_bx, ph_x1, ph_top)
    box.set_rightbottom(ph_bx, ph_x1, ph_btm)
else
    ph_crossed := close > ph_top ? true : ph_crossed
    
    if ph_crossed
        box.set_right(ph_bx, ph_x1)
    else
        box.set_right(ph_bx, n+3)

if showTop
    //Set ph zone
    set_zone(ph, ph_x1, ph_top, ph_btm, ph_count, ph_vol, topAreaCss)

    //Set ph level
    set_level(ph, ph_crossed, ph_top, ph_count, ph_vol, topCss)

    //Set ph label
    set_label(ph_count, ph_vol, ph_x1, ph_top, topCss, label.style_label_down)

//-----------------------------------------------------------------------------}
//Display pivot low levels/blocks
//-----------------------------------------------------------------------------{
pl = ta.pivotlow(length, length)

//Get pl counts
[pl_count, pl_vol] = get_counts(pl, pl_top, pl_btm)

//Set pl area and level
if pl and showBtm
    pl_top := switch area 
        'Wick Extremity' => math.min(close[length], open[length])
        'Full Range' => high[length] 
    pl_btm := low[length]
    
    pl_x1 := n - length
    pl_crossed := false

    box.set_lefttop(pl_bx, pl_x1, pl_top)
    box.set_rightbottom(pl_bx, pl_x1, pl_btm)
else
    pl_crossed := close < pl_btm ? true : pl_crossed

    if pl_crossed
        box.set_right(pl_bx, pl_x1)
    else
        box.set_right(pl_bx, n+3)

if showBtm
    //Set pl zone
    set_zone(pl, pl_x1, pl_top, pl_btm, pl_count, pl_vol, btmAreaCss)
    
    //Set pl level
    set_level(pl, pl_crossed, pl_btm, pl_count, pl_vol, btmCss)

    //Set pl labels
    set_label(pl_count, pl_vol, pl_x1, pl_btm, btmCss, label.style_label_up)

//-----------------------------------------------------------------------------}

// Candlestick patterns
//"open" is the share price at the start of market hours 
open_today = open 
open_1_day_ago = open[1]
open_2_days_ago = open[2]
open_3_days_ago = open[3]

//"close" is the share price at the end of market hours 
close_today = close
close_1_day_ago = close[1]
close_2_days_ago = close[2]
close_3_days_ago = close[3]

//"high" is the highest a share price has gone during market hours 
high_today = high
high_1_day_ago = high[1]
high_2_days_ago = high[2]
high_3_days_ago = high[3]

//"low" is the lowest a share price has gone during market hours 
low_today = low 
low_1_day_ago = low[1] 
low_2_days_ago = low[2]
low_3_days_ago = low[3]

//Green candles signify a time period where the share price has gone up 
green_candle_today = open < close
green_candle_1_day_ago = open[1] < close[1]
green_candle_2_days_ago = open[2] < close[2]
green_candle_3_days_ago = open[3] < close[3]

//Red candles signify a time period where the share price has gone down 
red_candle_today = open > close
red_candle_1_day_ago = open[1] > close[1]
red_candle_2_days_ago = open[2] > close[2]
red_candle_3_days_ago = open[3] > close[3]

//Doji's are candles representing indecision and have thin bodies (represented by the small gap between the open and close of a candle) 
doji_1_day_ago_green = (green_candle_1_day_ago) and 
 close_1_day_ago - open_1_day_ago <= (close_1_day_ago + open_1_day_ago) * 0.001 
doji_1_day_ago_red = (red_candle_1_day_ago) and 
 open_1_day_ago - close_1_day_ago <= (open_1_day_ago + close_1_day_ago) * 0.001 


// CHART WARNING TEXT
var tab   = table.new(position = position.top_right, columns = 1, rows = 1, bgcolor = color(na), border_width = 1)
if barstate.islast
    if timeframe.in_seconds(timeframe.period) > 15 * 60
        table.cell(tab, 0, 0, text = 'Please use a timeframe <= 15 minutes', text_color=#FF0000)